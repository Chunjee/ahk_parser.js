move c past whitespaces

if it doesn't start with /*

if char===';' skip rest of line


string:

if ", and if next c+1 < length, if c+1==='"'


FUNCTION:
  get alphaNum, if not a number like 123(), it's a function.


finding a *.d.ts bundler (typescript declaration files):
  tried (didn't wor):
    ts-loader: declaration-bundler-webpack-plugin
      https://github.com/TypeStrong/ts-loader#declarations-dts
      https://www.npmjs.com/package/declaration-bundler-webpack-plugin
    dts-bundle-generator:
      Project seems dead. dts-bundle-generator looks like an alternative. #83
        https://github.com/TypeStrong/dts-bundle/issues/83
      https://github.com/timocov/dts-bundle-generator
  dts-bundle worked:
    https://github.com/TypeStrong/dts-bundle


src -> src/parser/ and src/usage.ts
because I don't want usage.ts to be bundled.


webpack.config.js -> build\webpack.config.js with build\dtsBundle.js & build\unlink_d.ts.js


`yarn declarations`(tsc --emitDeclarationOnly) isn't needed because `yarn webpackProd` somehow produces the declaration files...
  note the "include": ["src/parser/**/*.ts"], (in tsconfig.json) `yarn webpackProd` somehow respects that


removed sourcemaps (I don't think I need sourcemap in prod):
(idk what options do) https://webpack.js.org/configuration/devtool/
removed:
  (package.json) webpack --devtool hidden-source-map
  (webpack.config.js) // devtool: 'nosources-source-map',


(webpack.config.js)    
//https://webpack.js.org/guides/author-libraries/#expose-the-library
    library: {
      name: 'ahkParser',
      type: 'umd',
},
idk what library.name does, but I'm using camelCase because the example is `library: "webpackNumbers",`
it seems that it's used in script tag
<script>
  window.webpackNumbers.wordToNum('Five');
</script>


what if I only want the .js and NOT the .d.ts
just like lodash and @types/lodash, I put @types/ahk_parser.js in /types/package.json
notice that ahk_parser.js & @types/ahk_parser.js are in the same repo, but they won't be when published, because
package.json: files: [only takes index.js], and /types/ will be it's own npm package

how to use locally:
yarn add link:../ahk_parser.js
yarn add -D link:../ahk_parser.js/types

from npm package registry: idk yet

REORGANIZED
while (c < numCharsMinusOne) {
  if (whiteSpaceObj[lines[i][c]]) {
    c++
    continue
  } else if (lines[i].slice(c, c + 2) === '*/') {
    everything.push({type: 'MultilineComment', lineStart: multiLineCommentLineStart, colStart: multiLineCommentColStart, lineEnd: i, colEnd:c + 2})
    // d('MultilineComment END', l())
    i++
    break outer2
  }
  break
}
->
//skip through whiteSpaces
while (c < numCharsMinusOne && whiteSpaceObj[lines[i][c]]) {
  c++
}

//if line starts with */
if (lines[i].slice(c, c + 2) === '*/') {
  everything.push({type: 'MultilineComment', lineStart: multiLineCommentLineStart, colStart: multiLineCommentColStart, lineEnd: i, colEnd:c + 2})
  // d('MultilineComment END', l())
  break
}

a line can start with:
HOTKEY:
  $^+left::

can this be a var ?
  $
  yes

  #NoEnv
  yes, but you can't assign it like this #NoEnv :=4, you can't have a space

  #include
  same

  #if
  same

  #ANYDirective
  same

  #
  fine variable, # :=3, still works as a var

  return
  fine variable, return :=3

  if
  yes, but if :=, becomes an if statement? (not confirmed)

  for
  fine variable, for :=3, still works as a var, what a surprise

  ExitApp
  fine variable, ExitApp :=3

#NoEnv is actually just a statement just like Send, ignore the # if it helps

when is it incorrect to skip spaces ?

I shouldn't skip spaces for:
  function definition

#Include though

NO SPACE: ASSIGNMENT
#NoEnv:=2
SPACE: STATEMENT
#NoEnv :=2

check if assignment
skip spaces
check if statement, else assignment

continue Trie: IT, will tell if assignment or statement ?
if not found in Trie: oof ?

so lets fill our Trie with
:=
#NoEnv

and setup a test

oh I cannot, it only does the variable name
I can use 2 Trie

if statement:
  if space:
    isSTATEMENT
  if end of line:
    isSTATEMENT
  if comma:
    isSTATEMENT
  else:
    is FUNCTION CALL ?
    is FUNCTION DEFINITION ?
    is assignment ?

if undefined:
  is FUNCTION CALL ?
  is FUNCTION DEFINITION ?
  is assignment ?

ok, it's the same pattern, good

but now, the end of trie, doesn't HAVE to be a function anymore, it can just be the TYPE
'statement'
instead of an object
{}

in fact, this trie can be a trie of ONLY statements. what else can there be ? hOtKeys...
#k::
ok fiouf, hotkeys can only be one CHAR
so
#if::
is impossible, I'M SPARED

omg
if :=2
this become an ACTUAL "if statement" (not confirmed)

not every statement becomes a statement if SPACE
for ex: "for :=2" is a fine variable.

if SpaceStatement:
  if space:
    isSTATEMENT
  if end of line:
    isSTATEMENT
  if comma:
    isSTATEMENT
  else:
    is FUNCTION CALL ?
    is FUNCTION DEFINITION ?
    is assignment ?

if WeakStatement:
  if end of line:
    isSTATEMENT
  if comma:
  HMMMMMMMMM
    for, doesn't work: FOR IS A CONTROL STATEMENT: which works with { block }
    isSTATEMENT
  else:
    is FUNCTION CALL ?
    is FUNCTION DEFINITION ?
    is assignment ?

if undefined:
  is FUNCTION CALL ?
  is FUNCTION DEFINITION ?
  is assignment ?


if trie ends at Control, it can't continue to ControlClick
dump trie, use if (object['control']=="SpaceStatement")

PLEASE, just write, REORDER AFTER

if FUNCTION:
if SpaceStatement:
  if space:
  if end of line:
  if comma:
    isSTATEMENT
skipSpaces
if ASSIGNMENT:

else:
  ???

it's control.directives, not statement: from ahk.tmLanguage.json
allowsamelinecomments|clipboardtimeout|commentflag|errorstdout|escapechar|hotkeyinterval|hotkeymodifiertimeout|hotstring|if|iftimeout|ifwinactive|ifwinexist|ifwinnotactive|ifwinnotexist|inputlevel|installkeybdhook|installmousehook|keyhistory|ltrim|maxhotkeysperinterval|maxmem|maxthreads|maxthreadsbuffer|maxthreadsperhotkey|menumaskkey|noenv|notrayicon|persistent|singleinstance|usehook|warn|winactivateforce

they're called #Directives in https://www.autohotkey.com/docs/commands/index.htm
and ControlClick is a Command

\ahk_parser.js\ahk_language\flow of control\is if assign an actual if\test38.ahk
;yes, `if :=4` is an actual if statement

oof.
LABELS:
if:
global, local, static
hotkey

ImageListID%A_Index% := IL_Create(50)

METHOD CALL:
LV_Colors.Cell(ListviewHwnd%whichSide%,row,3,color)

let's deal with METHOD CALL First.

now the question is: variable assignment first, or labels and hotkeys ?
var assignment: char==="%" or validChar[char]

well, it's now or never to be a label: because label can't have %

this is NOT a label
$enter::
$enter: ;this is a label

so:
skip whiteSpaces
if EOL or semiColonComment
it's a label

let's do varName first, hotkeys have more special chars

varName can be assignment, function, method.

COMMAND EOL:
  break
  return
  Exitapp
  ToolTip
  else
  global
  Else
  Return
  continue
  #Persistent

looks good to me

.\found\COMMAND comma\unique: looks good to me

whiteSpace DIRECTIVE:
  #NoEnv
  #KeyHistory
  #include
  #if
good

if statement: too many but is working fine

global local or static: works

.\found\FUNCTION CALL OR DEFINITION\unique: seems good now

this is NOT a METHOD call:
  str.=v[key] "+" k "|"
so check if the next character is a valid Var

.\found\METHOD OR PROPERTY\unique: good now

fixed //#LABELS with c++: need to advance it
.\found\LABEL EOL\unique: looks fine

LABEL SemiColonComment: not found but tested and works:
  gsaveSettings: ;labels

  gsaveSettings:  LABEL SemiColonComment 16 line 161

.\found\HOTKEY validVarName\unique: GOOD

var can have space between assignment
var .=

but hotkey can also, oh god
LShift & RCtrl::
Ralt & m::

fiouf label can't have spaces
label :

so I am both here and here
 .=
 & RCtrl::

skip spaces
if assignment operator:
  ok
skip spaces OR HOTKEY stuff: &^#$ (this risks skipping everything, must limit it to line)
if ==='::'
  ok

.\found\2 char assignment operator\unique: good

invalid hotkey:
msgboxx,::msgbox, 4
good msgbox:
msgbox,::msgbox, 4

so I must check if it's a valid command
or I can do, if invalid hotkey: it's a command ?

so now I need to know WHICH COMMANDS will be a command when:
COMMAND,::
COMMAND ::
I need to be REALLY careful because there are command like FileRecycleEmpty: Empties the recycle bin.

I will do one thing for now: COMMAND comma test
ima test SOME.

hotkeys can have commands:
  f3::Exitapp
so no, hotkeys don't end with ::

all this is validVarName:
  whiteSpace directive
  virtual skip whiteSpaces:
    variable assignment
  whiteSpace directive OR Command
  hotkey

well, if there was no whiteSpace, it has NO CHANCE. of being anything
so let's start there

whiteSpace:
  directive?
  skip spaces:
    validVarName assignment ?
  Command?
hotkey

whiteSpace DIRECTIVE; validVar assignment; whiteSpace COMMAND

why isn't this being caught as hotkey ?
  ; invalid hotkey
  msgbox%::msgbox, 4

skip ONLY if c==0
fixed

`;:: works because currently if it start with ';' it's a comment
AND ONLY if it start with it. so:
  command ;fefef
wouldn't be detected

now let's do assign:
var:=expression:
  ok:=foo:=2 + bar:=4
  p(ok) ;6

expression can be:
  unit:
    var:var
    func: Substr(), Map()
    number:123
    string:"123"
    object literal:{ok:45,"?":3}:
      {string|prop : expression}
    array:[1,2,3,"3"]:
      [expression]

decimal numbers are not method calls, because they are not validVarName 123.34() : 123 is not validVarName
so, if . and number: it's DECIMAL, or float..

Integer, Float, %Var%

if one validVarName:
  skip until not validVarName
  if (:
    Func
  else if .
    if Number:
      DECIMAL
    else:
      method or prop
  else:
    var

//#unit
skip whiteSpaces
if EOL OR ;
  Continuation stuff
if % or validVarName
  skip until not validVarName
  EOL:
    isNotNumber:
      valid var
    else:
      Integer
  if .
    if Number:
      DECIMAL
    else:
      method or prop
  skip until not % OR validVarName
  EOL:
    %VAR% : can't be integer
  if (:
    Func
  if .
    method or prop
  else:
    isNotNumber:
      var
    else:
      Integer
else if "
else if ( paren for ternary or order of operations
else if [ array literal
else if { object literal
else:
  ???

oh no, it can be an array accessor.
var[2]

valid is a subgroup of % or valid

nonoononononono
var:= CmdLine := ( A_IsCompiled ? "" : """" A_AhkPath """" )

now let's do string concat expression ?

I need to understand how operators work because whiteSpace is an operator.
 concat operator, when there are no other operators

so, I'll start with +
var + var
after I found a var, I check if there's an operator.
better check for assignment first, += before +

what about whiteSpace?
+
a
operator AND whiteSpace
operator WITHOUT whiteSpace
concat AND whiteSpace

skip whiteSpaces
if EOL, return
check if assignment
check if operator
check if whiteSpace[lines[i][c - 1]]

OR

check if whiteSpace[lines[i][c - 1]]:
  skip whiteSpaces
  if operator:
    operator
  if assignment:
    assignment
  else:
    concat
if operator:
if assignment:

ok I'll choose the first one

comparison operators ARE operators
assignment operators are also operators...

oh, NOT, AND, OR, are reserved, they can't be variables.

I'll do paren now: 
( expression )

assignment CAN be EOL, so expect multilineParenExpr
var:=
(
"abc" foo   
)

THIS DOESN'T CONCAT
var:=
(
"abc" foo{WHITESPACE}
)
(
"abc" foo
)
BUT THIS DOES
var:=
(
"abc" foo
)
(
{WHITESPACE}"abc" foo
)

I should read this https://www.autohotkey.com/docs/Scripts.htm#continuation

The default behavior of a continuation section can be overridden
by including one or more of the following options to the right
 of the section's opening parenthesis. 
 If more than one option is present, 
 separate each one from the previous with a space. 
 For example: ( LTrim Join| %.
omg, so it's like a statement...

you are an expression, you do not know that you are inside
a continuation sequence, you don't care
your caller function knows.

what's the entry point ?
string EOL expect continuation
expression EOL expect continuation
only if not already inside continuation

my understanding is that when in continuation mode,
strings can go multiline

usually skipThroughEmptyLines() takes care of ; comments
but I don't want in continuation section, PLUS they are illegal

multiline comment in continuation?
no you can't, I'm saved.

oh cool, you can't have trailing comma on arrays
LEGAL
var1:=[1,"2"]
ILLEGAL
var1:=[1,"2",]

findPercentVar()

if (validVar)

try to be linear as possible..

now, function calls
how do I know if function call or definition?

foo(arg1, Byref arg2:=3) {
}

foo(arg1, Byref arg2:=3) 
{
}

foo([1,2,3],34)

this is illegal, cool
foo(arg1, Byref arg2:=3+3) {

:=number, string, bool

added exprFoundLine=-1, exprFoundLine=i first thing called by betweenExpression()

foo:="bar"
var2:={"4" foo:3  +3}
p(var2) ;4bar:6
var2:={foo:3  +3}
p(var2) ;foo:6
var2:={foo "4":3  +3}
p(var2) ;bar4:6
var2:={foo foo:3  +3}
p(var2) ;barbar:6

obj literal is dyn as long as it's not a single var
so if there's at least one betweenExpression

var2:={condition ? ifTrue : ifFalse : value}
p(var2)

2 implementations possible:
count how many ?
and if questionMarkCount
':' ends a ternary

OR

remove : from operators
when you see a ?, expect a :
this one is less recursive, but I'm more
comfortable with recursion ?

var:ok?no
1st would see :, and say, illegal
and do what ?

2nd: would not see it. and the line continues
because nothing found.

so 1st could see :, and continue line ?
knowing how deep probably is helpful

if 1operator === '?'

but it would say illegal when it sees
: of an object...
so let's just go with 2nd, expect a :

now that : isn't operator, it's concat...
I need to c++ after : , but still some concat

fixed concat, which is printed after because it needs to know if what's after is Expr

keep track of should there be a colon using colonDeep++ when obj or '?'

now how to check if obj key is single var or more? not now, it's not my buisness
keep track of an array?, always add to the newest and remove when done?

no, let's do functions

func definition:
validVar
findBetween
,
)


}

a strategy could be: find next ) , may be in another line oof
c++
skipThroughEmptyLines()
if lines[i][c]==='{'
come back
return true
else
come back
return false

if isFunctionDefinition() {

} else {
 enter function call 
}

I don't want lineLoop to do c=0
I need lineLoop to be a function because I
want to know when it ends. to wrap } ?
{ lineLoop 
}

I could just look for starting } in lineLoop
oh, what about func in func ?
Functions cannot contain functions,
the program will exit

lineLoop, which does c=0
and startOfLineLoop, which does nothing

I need to make sure any continue/break becomes continue lineLoop

here's how to use it:
  usingStartOfLineLoop = true
  skipThroughWhiteSpaces()
  continue startOfLineLoop

skipThroughEmptyLines skip ; at start of line c === 0 || whiteSpaceObj[lines[i][c - 1]]

1 AND (2 OR 3) instead of (1 AND 2) OR 3

lets start methods

https://www.autohotkey.com/docs/Concepts.htm#names
# @ $

LEGAL:
  var2:=a.b.c
  [betweenExpression]var3:=2
ILLEGAL:
  var1:=a.b.c [betweenExpression])ger
  var3:=2
why does [betweenExpression] end ?
insideContinuation is false
findBetween is false
insideContinuation is false
so it skipped lines until find something
if something is a between, check
if blocked by invalid, I can flag invalid
if blocked by valid, oof
then I should check if still on the same line
I mean, on the same line as last found: exprFoundLine

now let's do arr/map access
I think it's like a group.

then do decimal numbers

then turn continuation into an operator

d(`${validName} assignment`)
I don't need the i++ because it skips lines

when stringContinuation Ends, what does it do?
it will try to find end of string, if it can't, then return false
but its return value is ignored
findDoubleQuotedString() will return true
after betweenExpression(), ch() === '"'
I think it will expect another continuation section
no, it doesn't
I will make it do so.
if not inside and endStringContinuation returns false
normally, when endStringContinuation returns false
insideContinuation = false

Ended and didn't find end of string
start a new continuation section
finds illegal char

then findDoubleQuotedString should return false
no still return true but skipThroughEmptyLines()

maybe I need more abstract thinking
after )END METHOD, it will betweenExpression

I must reorganize my code now..

what's the difference between betweenExpression() AND findBetween()
findDoubleQuotedString() is hard to understand

delimArr.ignoreTimes[index]-=1
property, property->ArrAccess can be followed by betweenExpression()
first
a.b-=1
if (!findMethodOrProperty()) {
  d('illegal property on startOfLine',char())
}
// true if method, false if prop
illegal property on startOfLine
ONLY if no betweenExpression()
in betweenExpression(): if findBetween(), return true
betweenExpression() will skipLines, so no need i++

return Expression
I don't want return Expr to be recognized as concat
why does findExprMatch the one on the next line ?
oof
skipThroughEmptyLines will skip through and go to the other return
statement can't have Expr if line changed...
// can't be betweenExpression() because whiteSpace := takes priority

why does ; return {1:2,"1":5} loop forever when 2 is fine ?
Integer:
        betweenExpression()
        return true
        vs
d('} object', char())
  colonDeep--, c++
      return true

adding betweenExpression fixes it lol

inBetweens*
in
string_getUntilWithInBetweensULTRA(Byref string, Byref getUntil, inBetweens*) {
is this legal ?
a(b,inBetweens *) {
}
YES IT IS

use variadicAsterisk = false

in string_getUntilWithInBetweensULTRA:
valid empty arr 19 line 2
] end 19 line 2
for idkVariable 8 line 4

concat error only if indented
let's go in betweenExpression()

concat ONLY if i === lineBeforeSkip

#TODO
  return 
  +2
  is LEGAL, but it's NOT
  an assignment

] ArrAccess 41 line 11
)END METHOD 42 line 11
illegal property on startOfLine 17 line 12
endDelims.Push METHOD 31 line 12

//a method can actually be assigned... property too
//if prop and no assignment
illegal property on startOfLine

delimArr.ignoreTimes Array/Map Access 53 line 44
[ ArrAccess 53 line 44
index idkVariable 59 line 44
] ArrAccess 59 line 44
ILLEGAL nonWhiteSpace '-' at findCommentsAndEndLine 60 line 44
} Function DEFINITION 29 line 45


if (!betweenExpression() && isProp) {
  instead of 
if (isProp && !betweenExpression()) {
because short-circuit

now I want to convert object to Map()

works, cool, now need quotes for singleVar
can Map keys be numbers ? YES

which chars are allowed as string key ? in v1
12 is a number, it's != "12":value

ahk_language\string keys chars allowed in obj.ahk
so it's propCharsObj in tokens.ts

skipSpaces
skip though propCharsObj
if found expression:
  (another propCharsObj or anything)
  it not NOT a singleVar anymore

if haven't expression, it is only illegal if haventFoundSingleVar, which is a valid key

NO, it doesn't work for obj in obj
omg, and thinking about arr in arr
we'll have to construct it with pieces, let's play legos

when in object, don't push to everything, 
push to THAT corresponding object

or I could just modify it directly and advance c and i
easy method

no, always do it the hard way

do not everything.push when Searching for function definition
do not skipThroughWhiteSpaces() when skipThroughFindChar(')')
do not skipThroughWhiteSpaces() when skipThroughEmptyLines()

validName needs to first check if there WAS an assignment operator
 before saying that YES, this was an assignment
so instead of push, splice so that it is second last

I also need to save these positions
const validNameEnd = c,validNameLine = i

'end of lineLoop' never happens

findCommentsAndEndLine() after '} function definition'

isFunctionDefinition() use it's own version of skipThroughEmptyLines()
without everything.push()

somehow for is skipped and skipThroughEmptyLines() is catching what's between for and index. is IS working correctly.
for                                index
so it's checking for whiteSpace assignment
if found assignment, it needs to keep the whiteSpaces found, it's inserting at 2nd last
but we don't want the whiteSpace between for and ... do we ?. do we ?
we do

the indent is doubled:
      endDelims := []
becomes
            endDelims := []

after 'emptyLines', there shouldn't be 'whiteSpaces'

when this happens, I'm sure it's because lineLoop is called which does c=0
we want startOfLineLoop instead

let's just copy what we have from 'assignment' to 'assignment whiteSpace'
works

concat "" 0LENGHT 7 line 7
concat " " 1LENGHT 12 line 9
concat "" 0LENGHT 9 line 9
ILLEGAL nonWhiteSpace ',' at findCommentsAndEndLine 18 line 9

shouldn't concat when it's on different lines
betweenExpression() shouldn't set lineBeforeSkip = i
because it doesn't know.

well I can rename lineBeforeSkip to lineWhereCanConcat


but now I get
ILLEGAL nonWhiteSpace 'i' at findCommentsAndEndLine 13 line 9
 13 line 9: it's before 'index'
    for                                index, delimArr in inBetweens {
for is 'command', that's good
findCommentsAndEndLine() should NOT be called on the line of 'for'
when 'command', a line should've been skipped, trace() to see which one came first
                if (i === 3) {
                  d(345345)
                  trace()
                }
'command' came first

NO, I got the wrong for, this is the right one:
{type:'idkVariable', text:'for', i1:8, c1:8, c2:11},
for should NOT be idkVariable

if (!betweenExpression()) { findExpression() }
WHY was this called ?

{type:'] Array', text:']', i1:7, c1:24},
why after '] Array', it went to line 134?
well, no, it was line 134 that called findExpression that simplify returned, so it came back
that's fine

{type:'emptyLines' i2:8
then what called this ?
it was probably called by findExpression() at 'for'
it seems that this hhas been called twice
omg it IS called twice, WHYYYYYY : line 139..
I forgot to remove the og findExpression() when pasting from 'assignment' to 'assignment whiteSpace'

      endDelims.Push(delim[2])
becomes
            endDelims.Push(delim[2])
indentation doubled again..

        everything.push({type: ') method', text:')',i1: i, c1:c})
        if (i === 11) {
          trace()
        }
line 340
i === exprFoundLine needs to be true I think

let's try
            if (i === exprFoundLine || i === 12) {
NO, it's this it needs
else {
            usingStartOfLineLoop = true
            continue startOfLineLoop
          }

now, the only thing missing is the } else.
I want to ignore that for now.

let's take line 15: i=14

// findCommentsAndEndLine() is called
replace it with '} function definition to EOL'
now it's identical, except for a newline in the end idk why

there shouldn't be 'newLine startOfLineLoop'
lets just check in the end, if illegal i1

{type:'newLine startOfLineLoop', text:'
', i1:59, c1:0},
]

      //nothing left, continue
      if (c === numberOfChars) {
        everything.push({type: 'newLine startOfLineLoop', text:'\n',i1: i, c1:c})
        i++
        continue lineLoop
      }

there are 60 lines total
adding a newline on i1:59 = line 60 would result in 61 lines

so if (i1 + 1 === howManyLines && text === '\n')
remove line

fix concat

TypeError: Cannot read property 'slice' of undefined
line 734:      const concatWhiteSpaces = lines[i].slice(beforeConcatBak, afterConcat)
the slice needs to happen in the past.
lines[i]->lines[concatLineBak]

v:=a b
works

lineBeforeSkip -> lineWhereCanConcat

let's try set lineWhereCanConcat when found assignment operator
works

now continuations

challenges:

var:="hello"
m:="
(
inside
)" var
p(m)

let's set lineWhereCanConcat when " ends
works

oh remember to remove lineWhereCanConcat assignments from bEfOre

m:="
(
inside
) var
(
inside2
)"

var is not detected as variable, that's good
[
{type:'assignment', text:'m', i1:0, c1:0, c2:1},
{type:'2operator', text:':=', i1:0, c1:1, c2:3},
]
nothing breaks, I'm done

now reconstruct it

time to test it against final boss: ahk_explorer
first, mute:
  stringContinuation START
  stringContinuation END
  concat

ahk_explorer:
oof, spams:
illegal function DEFINITION END 34 line 25

ILLEGAL nonWhiteSpace ',' at findCommentsAndEndLine 9 line 18
illegal function DEFINITION END 1 line 23

FileRead shouldn't be idkVar..
oh no, the dreaded v1 assignment
currentDirSearch=

var=
only for strings and %var% I guess
I should do a findV1Expr
a!==b is actually illegal.
a======b would assign '=====b' to a

so I should check before 'whitespace assignment' and 'assignment'

a=b
a=;
a= ;

it seems that whiteSpaces are trimmed
ima just set cNotWhiteSpace

now let's do %VAR%

whiteSpace v1Assignment

continuation section tomorrow.

clear variable:
var=

continuation:
rtrimmed, not ltrimmed
no semiColonComments, ; are literal

a=b     
(
 c ;comment
)                   d ;comment

d is rtrimmed, not ltrimmed, but comments are allowed

always check if continuation section when v1Assignment

saving this test:
a=ol%var%lo`%      ;comment
a=ol%var1%lo`%%var2%      ;comment

a=b     
    ;comment1
(
 c ;comment2
)                   d ;comment3
(
 c ;comment4
)     

this works:
a=b     
    ;comment1
(
 c ;comment2     
)

this works:
a=b     
    ;comment1
(
 c ;comment2     
)                   d ;comment3

works for:
a=b     
    ;comment1
(
 c ;comment2     
)                   d ;comment3
(
 e ;comment4     
)                   f ;comment5

findExpression() if out of lines: 'illegal empty assignment'

loadSettings( shouldn't be a function definition
found ) at 14 line 20

after 261, + is found, so not looking for any other
I need betweenExpression itself to be recursive ?
or it to be called recursively by another function

if (!recurseBetweenExpression()) { findExpression() }
replace ALL betweenExpression() with recurseBetweenExpression
lol works

ahk_explorer:
illegal l c:1 line:20 startContinuation#765

favoriteFolders:=StrSplit(favoriteFolders,"`n","`r")
loadSettings()

so after ') function'

recurseBetweenExpression() shouldn't call findExpression()

FOLDERID_Downloads := "{374DE290-123F-4565-9164-39C4925E467B}"
RegRead, v, HKCU\Software\M...

in reconstructed: RegRead line is blank

ILLEGAL nonWhiteSpace 'R' at findCommentsAndEndLine 1 line 24
it shouldn't be calling findCommentsAndEndLine()
i === exprFoundLine shouldn't be true

shouldn't it be lineWhereCanConcat ?
replace exprFoundLine with lineWhereCanConcat

ILLEGAL ) function startOfLine 14 line 20
        if (i !== lineWhereCanConcat) {
          d('ILLEGAL ) function', char())
        }

'function( startOfLine' should do lineWhereCanConcat=i

to do:
  fix findPercentVar()
  whichSide %VAR% 34 line 42 #988
  instead of 
  %whichSide %VAR% 34 line 42 #988
  and everything.push %VAR% instead of the whole assignment?

ILLEGAL ) METHOD 25 line 111

arr[a b]
can concat a WITH b
arr[a b] c
can't concat arr[a b] WITH c

omg I'm saved, you CAN.
arr[a b] c
is LEGAL

321[index] should be illegal
but still do it
just if (!isNaN) {
  tell it's illegal
}

to do meh:
123.2 += 1 is legal

you can only do lineWhereCanConcat=i, if it's a METHOD, you CANNOT if it's a PROPERTY
so I need a way to..

ArrayAccess too...
I mean a.b[index]

I need a function to know isMethodOrArrAcess
then I can do the rest of logic ?
but how does the rest of logic know if method or ArrAccess ?

no, I can just make a logic that returns when not validName and not .

to do:
'Integer part of Decimal startOfLine', I'm not really parsing Decimal anymore, the error handling would be crazy

ILLEGAL nonWhiteSpace '3' at findCommentsAndEndLine 31 line 177
        editPos:=[textSize[1]+30, 50]
it's the 3 after +
        editPos:=[textSize[1]]
+30 wasn't captured ?

      if (findArrayAccess()) {
        recurseBetweenExpression()
        return true
      }

ILLEGAL nonWhiteSpace ']' at findCommentsAndEndLine 45 line 178

illegal function DEFINITION END 1 line 368
'function definition with no param'

illegal R c:9 line:837 startContinuation#765

oh no
arr[1] = v1Expression
I'm scared
fiouf, it is legal but it doesn't assign

arr:=[1,2,3]
arr[1] = v1Expressionfeff
; p(arr)

and THIS is illegal:
obj:={}
obj.ok:="34535"
obj.ok=34535
p(obj)

this dissapeard:
FileRead, favoriteFolders, %A_AppData%\ahk_explorer_settings\favoriteFolders.txt
it's a 'comma DIRECTIVE OR COMMAND'

RegRead, v, HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders, % FOLDERID_Downloads
is still there though

it comes after
currentDirSearch  =
;%appdata%\ahk_explorer_settings

after
{type:'newLine whiteSpace v1Assignment', text:'
', i1:17, c1:0},

a%b%      := c
a      := c
{type:'assignment', text:'a%b%', i1:0, c1:0, c2:4},
it should be 'assignment whiteSpace'
but 'assignment whiteSpace' is only for validVar, not %VAR%

          //'assignment' can also contain whiteSpace
          //because this only catches validVar, not %VAR%
          // so whiteSpace %VAR% will be caught by 'assignment'

//#LABELS
//can't be :=
if (lines[i][c] === ':' && lines[i][c + 1] !== '=') {

bug:
a:=(b=1) ? 2 : 1
gives
a:=(b=1) ? 2 :1
AND
a:=(b=1) ? 2 :   1
gives
a:=(b=1) ? 2 :  1

ternary colon:
recurseBetweenExpression()
if (i === howManyLines) {return false}

if statement:

"if "
can only be followed by space, no comma.

if, (true) {
  p(234)
}
this would be a command, but one that doesn't exist.

https://www.autohotkey.com/docs/commands/IfExpression.htm

An If statement that contains an expression is usually differentiated from a traditional If statement such as 
if FoundColor != Blue by enclosing the expression in parentheses, as in if (FoundColor != "Blue"). However, this is not strictly required

In particular, the following are also common ways of writing an If (expression):

Starting with an open parenthesis but not fully enclosing the expression: if (x > 0) and (y > 0)
Starting with a function call: if InStr(a, b)
Starting with an operator such as not or !: if !MyVar

https://www.autohotkey.com/docs/Language.htm#if-statement
If Var op Value, where op is one of the following operators: =, <>, !=, >, >=, <, <=.
If Var [not] between Lower and Upper
If Var [not] in/contains MatchList
If Var is [not] Type
Any If statement which does not match one of the usages shown above is interpreted as If (expression).

These are some common points of confusion related to legacy If statements:

Variable names must be enclosed in percent signs only on the right-hand side of the operator.
between, in, contains and is are only valid in this context; they cannot be used in expressions.
Multiple conditions cannot be written on the same line (such as with the and operator).
None of the parameters are expressions.


if
skipThroughWhiteSpaces
  (
  var?
    op ?
    not ?
    value (v1 expr)

if () skipThroughEmptyLines
if { , else normal command (startOfLineLoop)

if (true) 
{p(345345)
}

but also startOfLineLoop EVEN IF found {

if var = v1Expr

legacyIfOperators
=, <>, !=, >, >=, <, <=
in tokens.ts

THIS IS VALID:
var:=1
str:="intege"
if var is %str%r
p(345)

THIS TOO
var:=1
if var is % "integer"
p(345)

NO NEWLINE ALLOWED
if var 
is integer

omg this is legal, I'm saved
a=% "ok"
p(a)
this too...
a=% +="ok"

global lookingForAnd = false

illegal:
if Var in exe   ,% popo,ok   

LEGAL:
oof:="ba"
var:="bat"
if Var in exe   ,%oof%t,ok   
p(23)

LEGAL & both true:
; var:="exe   a,bat"
var:="k"
if Var in exe   a
,,

(
bat,k
),ok   

this is legal
a=b
;fwefe

,
!
/

?
? :  a
<<=
d(a)
; these will not: and, not, :
; ? : is illegal
; ? : a LEGAL
; produces "b, ! / ? ? :  a <<=" somehow whiteSpaces were added, but not before comma(,)

tokens: v1Continuator

to do:
  not every operator will continuation: ++ will not, well it isn't an operator..


          // the whiteSpaces before do count, if there was something before
a =
(
b
) c
"b c"
a =
(
) c
"c"

so, it seems that it's a simple concat

OMG: THIS IS LEGAL: AND TRUE
var:="c"
if var between
(
bat and k
)
p(123)

        // inside continuation, whiteSpaces to the left do count

DONE:
 test between

DONE:
remove ALL {ws}, instead, use whiteSpaceObj

to do:
  function CALL are O(slow) O(n^2) ??

ILLEGAL:
var=a
(
  b
) % "3"

ILLEGAL:
var=a
(
  b
) % "3"

THIS IS LEGAL:
if Var in % "a,b"


skipThroughEmptyLines() fixed:
  c = numberOfChars
  const text = textFromPosToCurrent([c1, i1])

if var contains ,,,


IfEqual, Var , Value          ; if Var = Value
IfEqual Var , Value          ; if Var = Value
IfEqual
, Var , Value          ; if Var = Value
OR

Note that command-like If statements allow a command or command-like control flow statement to be written on the same line
LEGAL
IfEqual, Var , Value, COMMAND LIKE          ; if Var = Value
IfEqual, Var , Value, sleep, 2          ; if Var = Value
IfEqual, Var , Value, return          ; if Var = Value
legal, but does nothing... , it also voids what comes below.
IfEqual, Var , Value, Expr          ; if Var = Value
IfEqual, Var , 4, x+=2          ; if Var = Value
IfEqual, Var , 4, f[;]5[]          ; if Var = Value

IfWinActive , ahk_exe code.exe,,,, msgbox, hello
crazy huh ?

idkType === 4

msgbox 
(
j
)

---------------------------
ahk_parser.js test36.ahk
---------------------------
Error at line 459.

Line Text: msgboxj
Error: This line does not contain a recognized action.

The program will exit.
---------------------------
OK   
---------------------------
omg, it really does A LOT of preprocessing

line 278 // oof, command here
I'm just going

current command ORDER:

'command EOL'
'comma DIRECTIVE OR COMMAND'
'directive'
'= whiteSpace v1Assignment'
'assignment whiteSpace'
'command'

comma DIRECTIVE CAN take precedence, but it won't

comma DIRECTIVE can have spaces or lines in between, so it should be after.
same as comma EOL, which shouldn't even exist. because you can comma continue. so expect a comma, or continue.

if (c === numberOfChars) {
  just skip..
  anything that checks the LINE only


IfEqual
,

IMPORTANT:
'directive'
'assignment'
'command'

'assignment'

omg, the comma is optional, this is the worst...
comma is only useful for multiline

after whitespace command or eol command
check for comma: good idea

first, do EOL

nested namedIf kinda works..

EOL, whitespace, or comment

"if "
bad,
it could be tab

uh oh..
this is legal
if {1:2,4:56,6:3}.count() == 3 {
  p(345)
}

{1:2}.count() is legal
it's not validvar.count()


if "fwef" . "564g" {

}

there shouldn't be object after string.
well, no obj when concat

ok, this is legal and true
if {1:2,4:56,6:3}.count() == 3 . [  456 ] {
  p(78)
}
this too
if {1:2,4:56,6:3}.count() == 3 . {} {
  p(78)
}
so if concat = true, do not obj


    if (okk && i === 3) {
      d(c, numberOfChars)
      trace()
      // process.exit()
    }
          d(c)
      okk = 1

v:="t"
for a, %v% in [1,2,3] {
  p(t)
}

//if whiteSpace in v1String, then illegal variable Name
but this is legal and NOT skipped by skipWhiteSpaces()
for
(
  ue
) in [1,2,3] {
}

findingVarName = true
varNameCanLtrimSpaces when findVariableName

only 1 line of continuation section is allowed for var name, because no newline in varName.
when found AnyVarName, varNameCanLtrimSpaces=false

I need to note down

skipCommaAssignment(), LOL, just write functions

infinite for

return Expr
return, Expr
return
, Expr
, ok()
all work

skip, if comma.
if same line: find
else: staroflineLoop

if statement:
  skipThroughEmptyLines
  if whiteSpace + SameLine:
    if comma:
      c++
    find V1 OR find V2
  else:
    if comma:
      c++
      //ONLY if comma
      find V1 OR find V2
    

if statement:
  skipThroughEmptyLines
  if comma:
    commaFound
    c++
  if whiteSpace + SameLine:
    if !commaFound:
      look assignmentOperators
    find V1 OR find V2
  else if (commaFound)
    find V1 OR find V2

if statement:

  saveLine

  skipThroughEmptyLines
  if comma:
    c++
    find V1 OR find V2
    startOfLineLoop
  else if sameLine && whiteSpace :

    BUT `msgbox ;` isn't a command. well, it IS. It's v1Str's job to see that it's a comment
      a= b ; comment

    look assignmentOperators
    find V1 OR find V2



skipThroughEmptyLines
if statement:
  if comma:
    c++
    find V1 OR find V2
    startOfLineLoop
  else if sameLine && whiteSpace :

    //if #directive
    if (idkType===1)
    else ('if')
    else if recurseBetweenExpression()
    //if global local or static{ws}
    else if (idkType === 3)
      global
    else ('return')
    else
      find V1 OR find V2
if sameLine && ':'
  label

how do I ?
find V1 OR find V2

SUMMIT OF PREPROCESSING: LEGAL AND does MSGBOX
msg
(
box
),hello


  else if sameLine && (whiteSpace || EOL) :

if statement:
  if skipThroughEmptyLines:
    if comma:
      c++
      find V1 OR find V2
      startOfLineLoop

      if recurseBetweenExpression()
    else if sameLine && whiteSpace :

      //if #directive
      if (idkType===1) (EOL)
      else ('if')
      else if recurseBetweenExpression() (EOL)
      //if global local or static{ws}
      else if (idkType === 3)
        global
      else ('return') (EOL)
      else
        find V1 OR find V2
  //EOL: ???    OR COMMENT ?????
  recurseBetweenExpression()
  startOfLineLoop

     
if sameLine && ':'
  label

loop forever at i===171

// I don't need to skip empty lines because the above does it for me

AFTER:
if (!recurseBetweenExpression()) { findExpression() }
CHECK:
if (i === howManyLines) { break lineLoop }

loop forever at i===300

c === 35, line 1438
36 finished ) group
c===39 line 233

AFTER:
'{'
c++
DO:
if (!skipThroughEmptyLines()) { break lineLoop }

do
else if
else

after }, don't return
'continue'
instead of only checking for if..
also check for else
if there's else, the if MUST have braces, right, right ?

NOPE
a:=",,"
if a = ,
p(345)
else if a = ,,
p(876)

ayt
a:="b"
if a = ,
p(345)
else if a = ,,
p(876)
else if a between b and c
p(666666)
else msgbox, hello
//is equivalent to
else

msgbox, hello

OMG, I'm done...
a:="2"
if a = ,
p(345)
else ifequal a, 2
p(876)

just startOfLineLoop

what about else { ? idk, block ?

you cannot have a comma after else

DONE:
loop % LV_GetCount()
so
Loop [, Count]
Loop [, v1Expression]

to do:
fix arrIndex assignment
ClrTx := This[H].Cells[Row][Col].T

to do:
skipCommaV2Expr should work for arrayIndex assignment
This[H].CurTX := This[H].TX, This[H].CurTB := 

DONE:
canConcat shouldn't be true
This[HWND].Rows := {}

to do:
MapIndexToID(HWND, Row) { shouldn't be MapIndexToID(HWND, ) {
AND
Detach(HWND) { shouldn't be Detach() {

to do:
  startContinuation() was rewritten, retest it.

to do:
  class
  must be space, cannot EOL, cannot comma
  validName
  not optional {


x:=","
while
, x = ","
p(45)


$^+left::
var : $
operator : ^ : bitwise-exclusive-or (^)

well 1+1 is illegal
1+=1 is legal

hotkey:
$=::
p($)
string:
$=`::
$=:`:

hotkey: SHIFT + EQUAL
$+=::
p(35)

Invalid hotkey:
#NoEnv::
so hotkey takes precedence

this works
"::\
"->\

hotkey:
msgbox::
msgbox:
msgbox ::

msgbox:
msgbox & e::

hotkey:
AppsKey Up::
because this isn't a command..
AppsKey & e::

spaces are allowed in hotkey if not a command...

check hotkey before assignment
$+=::

skipOperators, if ":", then hotkey

$+="::
$="::

to do:
  commands, recurse skipComma V1Expr

:=-1
looks for expression
but -1 requires 
if (assignmentOperatorReturnValue === 1) {
      if (!recurseBetweenExpression()) { findExpression() }

++i
i++
oof

I bet hotkeys are preprocessed:
e:=2
v:=2+
+e
p(v)

v:=2+
+e::

(+ is operator, so continue, BUT IT'S A HOTKEY)
the line must start with an operator, and if it's another line than before. check what ?

dumb solution, but it's what I got..
splice off anything starting from hotkey line if hotkey found
when operator not same line, save everything.length
spliceIndexEverythingAtHotkeyLine = everything.length

easy solutions
if (i === operatorAtHotkeyLine) {

to do:
illegal: unexpected : 
when hotkeyLine ?

a=
+3::
msgbox
+3::

actually DO, the commands
